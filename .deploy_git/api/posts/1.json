{"total":20,"pageSize":10,"pageCount":2,"data":[{"title":"游戏中写出的bug及思考","slug":"游戏中写出的bug及思考","date":"2020-06-16T01:48:20.000Z","updated":"2020-06-16T02:17:18.141Z","comments":true,"path":"api/articles/游戏中写出的bug及思考.json","excerpt":"","keywords":null,"cover":null,"content":"<p>1.写出的功能一定要兼容旧版本及新版本，因为更新的不及时会导致可能有部分用户是在用旧版</p>\n<p>2.node版本要用双数的正式版本，单数有个问题在时区的双数上会出现很大的问题</p>\n<p>3.进程间通信的逻辑一定要注意，进程间的内存是单独的，所以如果没有公共存储最好不要操作内存</p>\n","text":"1.写出的功能一定要兼容旧版本及新版本，因为更新的不及时会导致可能有部分用户是在用旧版2.node版本要用双数的正式版本，单数有个问题在时区的双数上会出现很大的问题3.进程间通信的逻辑一定要注意，进程间的内存是单独的，所以如果没有公共存储最好不要操作内存","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"Es6 js规范","slug":"js规范","date":"2020-06-09T09:59:15.000Z","updated":"2020-06-16T02:17:59.783Z","comments":true,"path":"api/articles/js规范.json","excerpt":"","keywords":null,"cover":null,"content":"<p>数组拷贝<br>const itemsCopy = […items];</p>\n<p>取值方式<br>const [first, second] = arr;</p>\n<p>函数初始化<br>function f3(a) {<br>  const b = a || 1;<br>  // …<br>}</p>\n<p>function f4(a = 1) {<br>  // …<br>}</p>\n<p>输出数组<br>const x = [1, 2, 3, 4, 5];<br>console.log(…x);</p>\n<p>new Date(…[2016, 8, 5]);</p>\n<p>数组遍历<br>let sum = 0;<br>numbers.forEach((num) =&gt; {<br>  sum += num;<br>});<br>sum === 15;</p>\n","text":"数组拷贝<br>const itemsCopy = […items];取值方式<br>const [first, second] = arr;函数初始化<br>function f3(a) {<br>  const b = a || 1;<br>  // …<br>}functi","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"基础知识","slug":"基础知识","date":"2020-05-22T06:42:58.000Z","updated":"2020-06-11T02:45:48.376Z","comments":true,"path":"api/articles/基础知识.json","excerpt":"","keywords":null,"cover":null,"content":"<p>异步：异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>\n<p>基本功能</p>\n<ol>\n<li><p>进程管理<br>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>\n</li>\n<li><p>内存管理<br>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>\n</li>\n<li><p>文件管理<br>文件存储空间的管理、目录管理、文件读写管理和保护等。</p>\n</li>\n<li><p>设备管理<br>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p>\n</li>\n</ol>\n<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>\n<ol>\n<li>ps<br>查看某个时间点的进程信息。</li>\n</ol>\n<p>示例：查看自己的进程</p>\n<h1 id=\"ps-l\"><a href=\"#ps-l\" class=\"headerlink\" title=\"ps -l\"></a>ps -l</h1><p>示例：查看系统所有进程</p>\n<h1 id=\"ps-aux\"><a href=\"#ps-aux\" class=\"headerlink\" title=\"ps aux\"></a>ps aux</h1><p>示例：查看特定的进程</p>\n<h1 id=\"ps-aux-grep-threadx\"><a href=\"#ps-aux-grep-threadx\" class=\"headerlink\" title=\"ps aux | grep threadx\"></a>ps aux | grep threadx</h1><ol start=\"2\">\n<li>pstree<br>查看进程树。</li>\n</ol>\n<p>示例：查看所有进程树</p>\n<h1 id=\"pstree-A\"><a href=\"#pstree-A\" class=\"headerlink\" title=\"pstree -A\"></a>pstree -A</h1><ol start=\"3\">\n<li>top<br>实时显示进程信息。</li>\n</ol>\n<p>示例：两秒钟刷新一次</p>\n<h1 id=\"top-d-2\"><a href=\"#top-d-2\" class=\"headerlink\" title=\"top -d 2\"></a>top -d 2</h1><ol start=\"4\">\n<li>netstat<br>查看占用端口的进程</li>\n</ol>\n<p>示例：查看特定端口的进程</p>\n<h1 id=\"netstat-anp-grep-port\"><a href=\"#netstat-anp-grep-port\" class=\"headerlink\" title=\"netstat -anp | grep port\"></a>netstat -anp | grep port</h1><p>#计算机网络<br>物理层、数据链路层、网络层、传输层、应用层<br>物理层：<br>单工通信：单向传输<br>半双工通信：双向交替传输<br>全双工通信：双向同时传输</p>\n<p>数据链路层：<br>模拟信号转换成数字信号，封装成帧等特点</p>\n<p>网络层：<br>IP协议</p>\n<p>传输层：<br>TCP/UDP协议</p>\n<p>应用层：<br>HTTP协议</p>\n<p>长连接与短连接的理解：<br>之所以网络上说HTTP分为长连接和短连接，其实本质上是说的TCP连接。TCP连接是一个双向dao的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。<br>因此“HTTP连接”这一概念压根就不应该出现，HTTP只是一个应用层的协议，根本就没有连接这一说法，就像FTP协议一样，我们从来不会说“FTP连接”吧。归根到底，其实说的连接都是只传输层的TCP连接。相反说HTTP请求和HTTP响应反而更加准确一些都是通过TCP连接这个数据通道来传输请求和响应的。<br>说到这里就彻底的改变了之前的错误认识，以后记住长连接，短连接都是指的传输层的TCP连接，而不是应用层的HTTP协议。HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。<br>现在的疑问<br>既然说到了长连接，那么什么是长连接，短连接呢？HTTP1.1中又是如何实现长连接的呢？那么长短连接又分别有什么优缺点呢？正如我们学习一个新知识的时候，总是会问自己这三个问题一样：XXX是什么？XXX怎么用？XXX的好处？像我们一般的普通web应用，csdn写博客的平台，这种采用长连接有什么用呢？<br>1，如何理解HTTP协议是无状态的<br>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。<br>2，什么是长连接、短连接？<br>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：<br>Connection:keep-alive 服务器和客户端都要设置<br>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。<br>3，TCP连接<br>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接 时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。<br>经典的三次握手示意图：<br>经典的四次分手关闭图：<br>4，TCP短连接<br>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server<br>发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起<br>close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，<br>短连接一般只会在<br>client/server间传递一次读写操作。<br>短连接的操作步骤是：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接<br>5，TCP长连接<br>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，<br>它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。比如你请求了csdn的一个网页，<br>这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，<br>基本要建立几个甚至几十个TCP连接，但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，<br>CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。<br>另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，<br>是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。<br>这一点其实很容易理解，否则的话，TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止。现在想想，对于服务器来说，<br>服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛，对不对？<br>长连接的操作步骤是：建立连接——数据传输…（保持连接）…数据传输——关闭连接</p>\n","text":"异步：异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。基本功能进程管理<br>进程控制、进程同步、进程通信、死锁处理、处理机调度等。内存管理<br>内存分配、地址映射、内存保护与共享、虚拟内存等。文件管理<br>文件存储空间的管理、目录管理、文件读写管理和保护","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"游戏运营活动框架思路","slug":"游戏运营活动框架思路","date":"2019-11-22T08:15:07.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"api/articles/游戏运营活动框架思路.json","excerpt":"<p>游戏的运营活动一般会有好多种类型，但是这些类型的功能一般是有共同和非共同的部分，这里记录一个对多类型运营活动的管理框架<br>通过模板表录入运营活动的参数，包括跳转模块，开启方法，红点方法，等级等。如果有类似活动结束发奖的奖励表也可以用表来记录不同活动operation_id对应的奖励<br>进行管理。<br><img src=\"1574411899.jpg\" alt=\"1574411899\"><br>1.初始化玩家排行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_sky_bless_rank() -&gt;</span><br><span class=\"line\">    List = [PlayerSkyBless || PlayerSkyBless &lt;- get_all_player_st_sky_bless(),</span><br><span class=\"line\">        PlayerSkyBless <span class=\"comment\">#player_st_sky_bless.bless_times &gt; 0],</span></span><br><span class=\"line\">    SortFunction = fun(A,B) -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>  A <span class=\"comment\">#player_st_sky_bless.bless_times =:= B #player_st_sky_bless.bless_times -&gt;</span></span><br><span class=\"line\">                A <span class=\"comment\">#player_st_sky_bless.last_time =&lt; B #player_st_sky_bless.last_time;</span></span><br><span class=\"line\">            <span class=\"literal\">true</span> -&gt;</span><br><span class=\"line\">                A <span class=\"comment\">#player_st_sky_bless.bless_times &gt; B #player_st_sky_bless.bless_times</span></span><br><span class=\"line\">        end</span><br><span class=\"line\">    end,</span><br><span class=\"line\">    SortList = lists:sort(SortFunction,List),</span><br><span class=\"line\">    Num = length(SortList),</span><br><span class=\"line\">    Tran = fun() -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>  Num &gt; 0 -&gt;</span><br><span class=\"line\">                lists:foreach(</span><br><span class=\"line\">                    fun(Seq) -&gt;</span><br><span class=\"line\">                        PlayerSkyBless = lists:nth(Seq,SortList),</span><br><span class=\"line\">                        lib_ets:insert(sky_bless_player_ranking,<span class=\"comment\">#sky_lantern_bless_player_ranking&#123;</span></span><br><span class=\"line\">                            player_id = PlayerSkyBless <span class=\"comment\">#player_st_sky_bless.player_id,ranking = Seq&#125;,replace),</span></span><br><span class=\"line\">                        BlessRanking = <span class=\"comment\">#sky_lantern_bless_ranking&#123;</span></span><br><span class=\"line\">                            ranking = Seq,</span><br><span class=\"line\">                            player_id = PlayerSkyBless <span class=\"comment\">#player_st_sky_bless.player_id,</span></span><br><span class=\"line\">                            <span class=\"built_in\">times</span>   = PlayerSkyBless <span class=\"comment\">#player_st_sky_bless.bless_times,</span></span><br><span class=\"line\">                            bless_time = PlayerSkyBless <span class=\"comment\">#player_st_sky_bless.last_time</span></span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        lib_ets:insert(sky_bless_ranking,BlessRanking,replace)</span><br><span class=\"line\">                    end,</span><br><span class=\"line\">                    lists:seq(1,Num)</span><br><span class=\"line\">                );</span><br><span class=\"line\">            <span class=\"literal\">true</span> -&gt;</span><br><span class=\"line\">                noop</span><br><span class=\"line\">        end</span><br><span class=\"line\">    end,</span><br><span class=\"line\">    game_db:<span class=\"keyword\">do</span>(Tran).</span><br></pre></td></tr></table></figure></p>","keywords":null,"cover":"1574411899.jpg","content":null,"text":"游戏的运营活动一般会有好多种类型，但是这些类型的功能一般是有共同和非共同的部分，这里记录一个对多类型运营活动的管理框架<br>通过模板表录入运营活动的参数，包括跳转模块，开启方法，红点方法，等级等。如果有类似活动结束发奖的奖励表也可以用表来记录不同活动operation_id对应","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"游戏","slug":"游戏","count":3,"path":"api/tags/游戏.json"}]},{"title":"游戏全局通知红点系统","slug":"游戏全局通知红点系统","date":"2019-08-23T09:44:00.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"api/articles/游戏全局通知红点系统.json","excerpt":"","keywords":null,"cover":"Red15669620461084.png","content":"<p>红点功能贯穿游戏所有功能，像是一个全局的通知，用一个配置表记录所有游戏功能及入口和红点、开启的方法名加载进内存<br><img src=\"Red15669620461084.png\" alt=\"Red15669620461084\"><br>主入口界面时候调用<br>取得已开启的功能列表mod_function:get_all_game_function() 构造成带父子关系的功能列表<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;Id,[&#123;GameFunction <span class=\"comment\">#game_function.id&#125;|List1]&#125;</span></span><br><span class=\"line\">|</span><br><span class=\"line\">lists:delete(&#123;Id,List1&#125;,L)</span><br></pre></td></tr></table></figure></p>\n<p>通过核心回调到所有模块的红点方法<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IsRed = <span class=\"keyword\">if</span></span><br><span class=\"line\">    Mod =/= <span class=\"string\">''</span>, Func =/= <span class=\"string\">''</span> -&gt;</span><br><span class=\"line\">        try erlang:apply(Mod,Func,[PlayerId]) of</span><br><span class=\"line\">            Result -&gt;</span><br><span class=\"line\">                Result</span><br><span class=\"line\">        catch</span><br><span class=\"line\">            _ : _ -&gt;</span><br><span class=\"line\">                <span class=\"literal\">false</span></span><br><span class=\"line\">        end;</span><br><span class=\"line\">    <span class=\"literal\">true</span> -&gt;</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">end,</span><br></pre></td></tr></table></figure></p>\n<p>最后将缓存中的玩家红点数据替换<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lib_ets:delete(player_red, PlayerId),</span><br><span class=\"line\">    lib_ets:insert(</span><br><span class=\"line\">        player_red,</span><br><span class=\"line\">        <span class=\"comment\">#player_red&#123;</span></span><br><span class=\"line\">            player_id = PlayerId,</span><br><span class=\"line\">            red_list  = N</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        replace</span><br><span class=\"line\">    ),</span><br></pre></td></tr></table></figure></p>\n<p>不同的功能触发红点改变需要有个打点的函数,在功能需要改变红点状态的时候通知进来更新缓存<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">notify_game_function_is_red (PlayerId,FunctionId) -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> mod_function:check_lock(PlayerId,FunctionId) of</span><br><span class=\"line\">        <span class=\"literal\">false</span> -&gt;</span><br><span class=\"line\">            noop;</span><br><span class=\"line\">        _ -&gt;</span><br><span class=\"line\">            GameFunction = code_db:get(game_function,[FunctionId]),</span><br><span class=\"line\">            Mod   = list_to_atom(GameFunction <span class=\"comment\">#game_function.red_mod),</span></span><br><span class=\"line\">            Func  = list_to_atom(GameFunction <span class=\"comment\">#game_function.red_func),</span></span><br><span class=\"line\">            IsRed = <span class=\"keyword\">if</span></span><br><span class=\"line\">                Mod =/= <span class=\"string\">''</span>, Func =/= <span class=\"string\">''</span> -&gt;</span><br><span class=\"line\">                   try erlang:apply(Mod,Func,[PlayerId]) of</span><br><span class=\"line\">                        Result -&gt;</span><br><span class=\"line\">                            Result</span><br><span class=\"line\">                    catch</span><br><span class=\"line\">                        _ : _ -&gt;</span><br><span class=\"line\">                            <span class=\"literal\">false</span></span><br><span class=\"line\">                    end;</span><br><span class=\"line\">                <span class=\"literal\">true</span> -&gt;</span><br><span class=\"line\">                    <span class=\"literal\">false</span></span><br><span class=\"line\">            end,</span><br><span class=\"line\">            <span class=\"keyword\">if</span></span><br><span class=\"line\">                GameFunction <span class=\"comment\">#game_function.relation &gt; 0 -&gt;</span></span><br><span class=\"line\">                    notify_relation_game_function_is_red(PlayerId,GameFunction <span class=\"comment\">#game_function.relation,FunctionId,IsRed);%通知父类联动的函数</span></span><br><span class=\"line\">                <span class=\"literal\">true</span> -&gt;</span><br><span class=\"line\">                    update_game_function_cache(PlayerId,FunctionId,IsRed)</span><br><span class=\"line\">            end</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n","text":"红点功能贯穿游戏所有功能，像是一个全局的通知，用一个配置表记录所有游戏功能及入口和红点、开启的方法名加载进内存<br> [Figure] ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"游戏","slug":"游戏","count":3,"path":"api/tags/游戏.json"}]},{"title":"游戏中大型自动比赛玩法设计","slug":"游戏中大型比赛玩法设计思路","date":"2019-07-30T08:08:45.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"api/articles/游戏中大型比赛玩法设计思路.json","excerpt":"<p>争霸赛赛程范例<br>3月1日 0：00~3月3日 12:00    报名    40级以上手动报名<br>3月3日 13：00    淘汰赛    “13:00取数据，提前1小时向玩家发送邮件提醒<br>13:10开始出战报，每隔5分钟出1场战报<br>天榜负5局进入地榜，地榜负5局则被淘汰”<br>3月4日 14:00    16强赛（32进16）    “每小时1局，每局取1次数据，5局3胜制<br>天地榜同时进行<br>比赛开始前1小时向玩家发送邮件提醒取数据制度”<br>3月5日 14:00    16进8<br>3月6日 14:00    8进4<br>3月7日 14:00    半决赛<br>3月8日 14:00    决赛<br>3月8日 决赛全部结束    统一发放奖励    </p>\n<p>比赛的时间控制由单独时间进程来控制时间的推进，相当于php中的crontab,表结构上一个玩家比赛进程表player_race,<br>一个各阶段玩家成员信息表player_race_member，后期系统匹配各阶段玩家匹配信息表player_race_opponent，<br>一个各阶段玩家战报信息表player_race_report，一个各阶段玩家结果表player_race_result，<br>玩家表可以分为  玩家比赛信息表  player_st_jjc_race 玩家匹配信息表 player_st_jjc_race_opponent 玩家日志表 player_st_jjc_race_score_log</p>\n<p>第一步 报名<br>很简单直接报名请求记录玩家数据就行,报名时间结束时触发事件对所有玩家进行匹配<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> try_get_player_server_war(PlayerId) of</span><br><span class=\"line\">    null -&gt;</span><br><span class=\"line\">        Tran = fun() -&gt;</span><br><span class=\"line\">            game_db:write(<span class=\"comment\">#player_server_war &#123;</span></span><br><span class=\"line\">                player_id  = PlayerId, </span><br><span class=\"line\">                apply_time = lib_misc:get_local_timestamp()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            % mod_deploy:get(PlayerId, ?RACE_SERVER_WAR)</span><br><span class=\"line\">        end, </span><br><span class=\"line\">        game_db:<span class=\"keyword\">do</span>(Tran);</span><br><span class=\"line\">    _ -&gt;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(already_apply)</span><br><span class=\"line\">end.</span><br><span class=\"line\"></span><br><span class=\"line\">% 本服报名结束手机玩家数据</span><br><span class=\"line\">apply_over() -&gt;</span><br><span class=\"line\">    List = get_all_player_server_war(),</span><br><span class=\"line\">    Tran = fun() -&gt;</span><br><span class=\"line\">        lists:foreach(</span><br><span class=\"line\">            fun(Rec) -&gt;</span><br><span class=\"line\">                game_db:write(Rec <span class=\"comment\">#player_server_war &#123;</span></span><br><span class=\"line\">                    race_step = ?RS_TIAN_BANG_TAOTAI</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            end, </span><br><span class=\"line\">            List</span><br><span class=\"line\">        )</span><br><span class=\"line\">    end,</span><br><span class=\"line\">    game_db:<span class=\"keyword\">do</span>(Tran),</span><br><span class=\"line\">    ?INFO(<span class=\"string\">\"apply_over\"</span>,[]),</span><br><span class=\"line\">    ZoneList = lists:foldl(</span><br><span class=\"line\">        fun(PlayerServerWar, R) -&gt;</span><br><span class=\"line\">            [PlayerServerWar <span class=\"comment\">#player_server_war.player_id | R]</span></span><br><span class=\"line\">        end,</span><br><span class=\"line\">        [],</span><br><span class=\"line\">        get_all_player_server_war()</span><br><span class=\"line\">    ),</span><br><span class=\"line\"></span><br><span class=\"line\">    mod_race:init_race_member(</span><br><span class=\"line\">       ?RACE_SERVER_WAR,</span><br><span class=\"line\">       0,</span><br><span class=\"line\">       ?RS_TIAN_BANG_TAOTAI,</span><br><span class=\"line\">       0,</span><br><span class=\"line\">       ZoneList,</span><br><span class=\"line\">       normal</span><br><span class=\"line\">    ).</span><br></pre></td></tr></table></figure></p>\n<p>注意的是用一个单独的进程来管理活动步骤开启结束<br><img src=\"Er15646489002180.png\" alt=\"Er15646489002180\"><br>","keywords":null,"cover":"Er15646489002180.png","content":null,"text":"争霸赛赛程范例<br>3月1日 0：00~3月3日 12:00    报名    40级以上手动报名<br>3月3日 13：00    淘汰赛    “13:00取数据，提前1小时向玩家发送邮件提醒<br>13:10开始出战报，每隔5分钟出1场战报<br>天榜负5局进入地榜，地榜","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"游戏","slug":"游戏","count":3,"path":"api/tags/游戏.json"}]},{"title":"Erlang List模块函数使用大全","slug":"Erlang List模块函数使用大全","date":"2019-05-07T11:49:16.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"api/articles/Erlang List模块函数使用大全.json","excerpt":"<p>Erlang List模块函数使用大全</p>\n<p>一，带函数Pred<br>1, all(Pred, List) -&gt; boolean()<br>如果List中的每个元素作为Pred函数的参数执行，结果都返回true，那么all函数返回true，<br>否则返回false</p>\n<p>例子：</p>\n<p>lists:all(fun(E) -&gt; true end,[1,2,3,4]).</p>\n<p>结果</p>\n<p>true</p>\n<p>2, any(Pred, List) -&gt; boolean()<br>如果List中至少有一个元素作为Pred函数的参数执行，结果返回true，那么any函数返回true，<br>否则返回false</p>\n<p>例子</p>\n<p>lists:any(fun(E) -&gt; is_integer(E) end,[q,2,a,4]).</p>\n<p>结果</p>\n<p>true</p>\n<p>3，dropwhile(Pred, List1) -&gt; List2<br>将List1列表中的元素作为参数执行Pred函数，如果返回true，将其丢弃，最后返回剩余元素<br>组成的列表</p>\n<p>例子</p>\n<p>lists:dropwhile(fun(E) -&gt; is_atom(E) end,[a,1,2,a,b]).</p>\n<p>结果</p>\n<p>[1,2,a,b]</p>\n<p>4，filter(Pred, List1) -&gt; List2<br>返回一个列表，这个列表是由List1中执行Pred函数返回true的元素组成。</p>\n<p>lists:filter(fun(E) -&gt; is_integer(E) end,[q,2,a,4]).</p>\n<p>结果：</p>\n<p>[2,4]</p>","keywords":null,"cover":null,"content":null,"text":"Erlang List模块函数使用大全一，带函数Pred<br>1, all(Pred, List) -&gt; boolean()<br>如果List中的每个元素作为Pred函数的参数执行，结果都返回true，那么all函数返回true，<br>否则返回false例子：list","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Erlang","slug":"Erlang","count":2,"path":"api/tags/Erlang.json"}]},{"title":"Erlang OTP学习","slug":"Erlang-OTP学习","date":"2019-04-09T08:50:32.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"api/articles/Erlang-OTP学习.json","excerpt":"","keywords":null,"cover":null,"content":"<p>1.-behaviour(gen_server)<br>它表示让编译器检查，当前module是否实现了gen_server指定的所有回调接口</p>\n<p>2.gen_server:start_link(ServerName, Module, Args, Options) -&gt; Result<br>这个方法用来启动一个server，其中：<br>参数ServerName指定了服务名<br>参数Module指定了该server的callback模块<br>参数Args将作为服务初始化的启动参数（服务初始化时会调用：Module:init([Args])）<br>参数Options指定了一些特性参数，通常可以直接使用[] </p>\n<p>如果服务启动成功，返回{ok, Pid} </p>\n<p>3.Module:init([Args])<br>这个方法会在服务初始化时被回调，参数Args就是gen_server:start_link中倒数第二个参数，若初始化成功，该方法放回{ok, State},其中State将作为启动服务的State </p>\n<p>4.gen_server:call(ServerRef, Request)<br>这个方法供callback模块向ServerRef代表的服务发送Request请求（callback模块通常会在之上再封装一层接口供客户端调用，譬如这里的add，find方法），注意该方法是一个同步调用，它会一直等待服务器返回一个响应消息（除非等待超时，默认5s） </p>\n<p>5.Module:handle_call(Request, From, State) -&gt; Result<br>这是一个回调方法，用来处理gen_server:call(ServerRef, Request)发出的请求，其中：<br>Request，表示客户端请求<br>From，表示请求来自哪个客户端<br>State，表示当前服务器状态 </p>\n<p>Result为handle_call 请求处理结果，它有以下几种类型<br>{reply,Reply,NewState}<br>{reply,Reply,NewState,Timeout}<br>{reply,Reply,NewState,hibernate}<br>{noreply,NewState}<br>{noreply,NewState,Timeout}<br>{noreply,NewState,hibernate}<br>{stop,Reason,Reply,NewState} | {stop,Reason,NewState} </p>\n<p>这几种返回值有什么区别呢？<br>如果返回的是以reply开头，那么Reply将会作为响应返回给客户端<br>如果返回的是以noreply开头，那么服务器将不会返回任何消息给客户端（这会导致客户端阻塞，因为客户端调用的gen_server:call方法是一个同步调用，当它发出请求后，会一直等待服务器发送响应消息，除非等待超时） </p>\n<p>6.gen_server:cast(ServerRef, Request)<br>这个方法同gen_server:call(ServerRef, Request)，但它最大的区别就是该调用是异步的，它不需要等待服务器返回任何处理结果 </p>\n<p>7.Module:handle_cast(Request, State) -&gt; Result<br>这个方法用来处理gen_server:cast(ServerRef, Request)发出的请求，由于不会返回结果给客户端，所以参数列表中也没有From </p>\n<p>8.检查进程是否加载<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erlang:whereis(?MODULE).</span><br></pre></td></tr></table></figure></p>\n<p>9.查看进程的信息<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erlang:process_info(pid(0,PID,0)).</span><br></pre></td></tr></table></figure></p>\n","text":"1.-behaviour(gen_server)<br>它表示让编译器检查，当前module是否实现了gen_server指定的所有回调接口2.gen_server:start_link(ServerName, Module, Args, Options) -&gt; Resul","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Erlang","slug":"Erlang","count":2,"path":"api/tags/Erlang.json"}]},{"title":"充值流程","slug":"充值流程","date":"2019-03-06T12:01:38.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"api/articles/充值流程.json","excerpt":"","keywords":null,"cover":null,"content":"<p>接触到的充值流程是这样的<br>客户端发起请求-&gt;lcm后台，lcm后台确认充值成功，会将充值的金额变成平台货币保存在平台端，并通知到客户端充值成功，<br>收到充值成功的客户端对游戏服务端发起请求，游戏服务端收到请求后，请求lcm平台调用spend方法，平台确认信息相符就扣币<br>并告诉游戏服务端消费成功，游戏服务端在将平台货币转换为对应的游戏币，同时告诉客户端充值成功</p>\n<p>2.平台充值成功可能会产生回调直接通知游戏服务端，服务端接收请求，后请求平台spend，成功后发币记录，客户端请求服务端查到有记录就告知客户端成功不做spend</p>\n<p>掉单：<br>如果掉单<br>1.平台回调请求会保证执行spend方法，达到补单的效果<br>2.客户端能读到平台币，直接通过平台剩余币与游戏服务端直接交易</p>\n<p>注意：<br>任何时间判断以天为单位要特别小心，如果出现两版批次连续很容易出问题</p>\n","text":"接触到的充值流程是这样的<br>客户端发起请求-&gt;lcm后台，lcm后台确认充值成功，会将充值的金额变成平台货币保存在平台端，并通知到客户端充值成功，<br>收到充值成功的客户端对游戏服务端发起请求，游戏服务端收到请求后，请求lcm平台调用spend方法，平台确认信息相符就","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"c++设计模式","slug":"c-设计模式","date":"2018-12-25T14:38:51.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"api/articles/c-设计模式.json","excerpt":"","keywords":null,"cover":null,"content":"<p>c++设计模式：</p>\n<p>简单工厂模式</p>\n<p>工厂模式有一种非常形象的描述，建立对象的类就如一个工厂，而需要被建立的对象就是一个个产品；在工厂中加工产品，使用产品的人，不用在乎产品是如何生产出来的。从软件开发的角度来说，这样就有效的降低了模块之间的耦合。</p>\n<p>使用情景：<br>  在不确定会有多少个处理操作时应该考虑使用简单工厂模式，如针对同样的接收到的数据，处理的逻辑可能会不同，可能以后还会增加新的操作。<br>案例：<br>如果实现计算器的功能时，对于同样的输入数据，可能执行加、减、乘、除，甚至其他的功能。因此可以抽象出一个操作的抽象类或是接口，提供一个统一的处理方法(此处为process)，然后每种操作创建出一个子类出来。而判断具体使用哪个具体的实现类是在工厂类中进行判断的(将存放操作的变量传递给工厂的生产方法)。工厂类始终返回的是这个抽象类，这样如果对原有功能进行更改或是新添加新的功能，也不会对原来的其他类做修改，只编译修改的那个类或是新的类就可以了。<br>这样就做到了把耦合降到最低，同时也便于维护。 </p>\n<p>简单工厂：针对同样的数据，不同的操作用同一个接口</p>\n<p>工厂方法：针对同样的数据，不同的操作用不同的接口</p>\n<p>抽象工厂：针对不同的数据，不同的操作用不同的接口</p>\n<p>策略模式：依赖c++的多态，抽象类的指针可以访问所有子类对象，（纯虚函数），可以用一个指针访问所有策略的实现类</p>\n<p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式(不能让一个程序打开两次  如：不能同时打开2个迅雷  迅雷用的单例模式)</p>\n<p>访问者模式:适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中(做任何更改不需要修改基类，不依赖虚函数)</p>\n<p>观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。(QT的信号机制，Windows的消息机制都应用了观察者模式，还有订阅邮件，邮件到了就会给你发邮件)</p>\n<p>建造者模式：使得产品内部表象可以独立地变化，客户不必知道产品内部组成的细节。可以强制实行一种分步骤进行的建造过程。用一个接口完成不同的操作，需要对客户的需求进行把握。(如：登陆QQ，自动选择所在地的服务器)</p>\n<p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。(如：360读取lua脚本，这个细节的实现就是解释器模式)</p>\n<p>命令模式：把发出命令的责任和执行命令的责任分割开，委派给不同的对象允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。(命令模式在客户端与服务器之间用的最多 (C/S架构))</p>\n<p>模板模式：不同的子类可以以不同的方式实现这些抽象方法，</p>\n<p>从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，</p>\n<p>而将逻辑的细节留给具体的子类去实现。(适用于本地化，做一个软件，在日本是日文，美国是英语…)</p>\n<p>桥接模式：将抽象化与实现化脱离，使得二者可以独立的变化，</p>\n<p>也就是指在一个软件系统的抽象化和实现化之间使用组合聚合关系而不是继承关系，从而使两者可以独立的变化。(相当于配电脑去装机，把各个模块组合到一起)</p>\n<p>适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。</p>\n<p>外观模式：外部与一个子系统的通信必须通过一个统一的外观对象进行。每一个子系统只有一个外观类，而且此外观类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个外观类。(多个子系统方法都需要一个外观类统一管理，用统一的接口方便消费者使用)</p>\n<p>享元模式：享元模式大幅度的降低内存中对象的数量，使用享元模式主要是为了优化内存，相同功能可以并行使用。</p>\n<p>原型模式：允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>\n<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。(例如：晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了)</p>\n<p>中介者模式：中介者模式包装了一系列对象相互作用的方式，</p>\n<p>使得这些对象不必相互明显作用。从而使他们可以松散偶合。</p>\n<p>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。（如：TCP/IP打洞技术）</p>\n<p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>\n<p>状态模式：意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。(如：到了晚上12点要睡觉，到了早上8点要起床…这就是状态)</p>\n<p>合成模式：将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。(用于树状结构)</p>\n","text":"c++设计模式：简单工厂模式工厂模式有一种非常形象的描述，建立对象的类就如一个工厂，而需要被建立的对象就是一个个产品；在工厂中加工产品，使用产品的人，不用在乎产品是如何生产出来的。从软件开发的角度来说，这样就有效的降低了模块之间的耦合。使用情景：<br>  在不确定会有多少个处理","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"c++ 设计模式","slug":"c-设计模式","count":1,"path":"api/tags/c-设计模式.json"}]}]}