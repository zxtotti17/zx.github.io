{"title":"redis笔记","slug":"redis笔记","date":"2018-08-01T08:52:31.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"api/articles/redis笔记.json","photos":[],"link":"","excerpt":"Redis是什么、特点、优势<br>redis是Key-Value数据库,数据包含各种数据 字符串String、字典Hash、列表List、集合Set、有序集合SortedSet等<br>redis支持数据持久化，重启再次加载,支持数据备份(支持分布式),Redis是单进程单线程的<br>Redis的优势<br>性能高 读速度110000/s 写速度81000/s<br>丰富的数据类型redis安装（Linux）、启动、退出、设置密码、远程连接<br>2.1 安装redis<br>下载redis安装包（如：redis-2.8.17.tar.gz）1<br>2<br>3<br>4<br>tar -zxvf redis-2.8.17.tar.gz<br>cd redis-2.8.17<br>make<br>sudo make install<br>2.2 后台启动服务端<br>1<br>nohup redis-server &amp;<br>2.3 启动客户端、验证<br>1<br>2<br>3<br>4<br>cd /usr/local/bin<br>redis-cli<br>set var \"hello world\"<br>get var<br>","covers":null,"content":"<ol>\n<li><p>Redis是什么、特点、优势<br>redis是Key-Value数据库,数据包含各种数据 字符串String、字典Hash、列表List、集合Set、有序集合SortedSet等<br>redis支持数据持久化，重启再次加载,支持数据备份(支持分布式),Redis是单进程单线程的<br>Redis的优势<br>性能高 读速度110000/s 写速度81000/s<br>丰富的数据类型</p>\n</li>\n<li><p>redis安装（Linux）、启动、退出、设置密码、远程连接<br>2.1 安装redis<br>下载redis安装包（如：redis-2.8.17.tar.gz）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf redis-2.8.17.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> redis-2.8.17</span><br><span class=\"line\">make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>2.2 后台启动服务端<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup redis-server &amp;</span><br></pre></td></tr></table></figure></p>\n<p>2.3 启动客户端、验证<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/bin</span><br><span class=\"line\">redis-cli</span><br><span class=\"line\"><span class=\"built_in\">set</span> var <span class=\"string\">\"hello world\"</span></span><br><span class=\"line\">get var</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<ol start=\"3\">\n<li><p>Reis key<br>序号    Redis keys命令及描述<br>1    DEL key<br>该命令用于在 key 存在是删除 key。<br>2    DUMP key<br>序列化给定 key ，并返回被序列化的值。<br>3    EXISTS key<br>检查给定 key 是否存在。<br>4    EXPIRE key seconds<br>为给定 key 设置过期时间。<br>5    EXPIREAT key timestamp<br>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。<br>6    PEXPIRE key milliseconds<br>设置 key 的过期时间亿以毫秒计。<br>7    PEXPIREAT key milliseconds-timestamp<br>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计<br>8    KEYS pattern<br>查找所有符合给定模式( pattern)的 key 。例如keys * 返回所有的key<br>9    MOVE key db<br>将当前数据库的 key 移动到给定的数据库 db 当中。<br>10    PERSIST key<br>移除 key 的过期时间，key 将持久保持。<br>11    PTTL key<br>以毫秒为单位返回 key 的剩余的过期时间。<br>12    TTL key<br>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。<br>13    RANDOMKEY<br>从当前数据库中随机返回一个 key 。<br>14    RENAME key newkey<br>修改 key 的名称<br>15    RENAMENX key newkey<br>仅当 newkey 不存在时，将 key 改名为 newkey 。<br>16    TYPE key<br>返回 key 所储存的值的类型。<br>…<br><a href=\"http://redisdoc.com\" target=\"_blank\" rel=\"noopener\">中文文档</a></p>\n</li>\n<li><p>Redis 发布订阅<br>占时没用过，看起来跟微信公众号一样,Pub/Sub做延时队列可以用在玩家登录排队上</p>\n</li>\n<li><p>Redis事务<br>一个事务从开始到结束经过以下三个阶段：</p>\n</li>\n</ol>\n<p>开始事务<br>命令入队<br>执行事务<br>例子</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localhost:6379&gt; MULTI</span><br><span class=\"line\">OK</span><br><span class=\"line\">localhost:6379&gt; <span class=\"built_in\">set</span> name jihite</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">localhost:6379&gt; get name</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">localhost:6379&gt; sadd language <span class=\"string\">\"c++\"</span> <span class=\"string\">\"python\"</span> <span class=\"string\">\"java\"</span></span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">localhost:6379&gt; smembers language</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">localhost:6379&gt; <span class=\"built_in\">exec</span></span><br></pre></td></tr></table></figure>\n<p>说明：事务以MULTI开始，以EXEC结束</p>\n<ol start=\"6\">\n<li>关闭持久化与持久化<br>(RDB)bgsave做镜像全量持久化，aof做增量持久化<br>RDB相当于快照，是fork一个子进程，快照成功后替换<br>aof相当于日志，cow，copy and write,一条一条的数据</li>\n</ol>\n<p>这是redis与其他缓存服务的比较明显的特点,如memcache<br>修改配置文件，改完后重启。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#save 900 1  </span></span><br><span class=\"line\"><span class=\"comment\">#save 300 10  </span></span><br><span class=\"line\"><span class=\"comment\">#save 60 10000</span></span><br></pre></td></tr></table></figure></p>\n<p>或执行操作命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET save <span class=\"string\">\"\"</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"7\">\n<li>redis相比memcached有哪些优势？</li>\n</ol>\n<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型<br>(2) redis的速度比memcached快很多<br>(3) redis可以持久化其数据</p>\n<ol start=\"8\">\n<li>redis常见性能问题和解决方案：</li>\n</ol>\n<p>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件<br>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次<br>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内<br>(4) 尽量避免在压力很大的主库上增加从库<br>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…</p>\n<p>这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</p>\n<ol start=\"9\">\n<li><p>Redis 常见的性能问题都有哪些？如何解决？<br>1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。<br>2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。<br>3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。<br>4). Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</p>\n</li>\n<li><p>Redis分布式锁<br>拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p>\n</li>\n<li><p>Redis做异步队列<br>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>\n</li>\n</ol>\n","categories":[{"name":"数据库","slug":"数据库","count":2,"path":"api/categories/数据库.json"}],"tags":[{"name":"redis","slug":"redis","count":1,"path":"api/tags/redis.json"}]}