{"name":"Erlang","slug":"Erlang","count":2,"postlist":[{"title":"Erlang OTP学习","slug":"Erlang-OTP学习","date":"2019-04-09T08:50:32.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"api/articles/Erlang-OTP学习.json","excerpt":"","keywords":null,"cover":null,"content":"<p>1.-behaviour(gen_server)<br>它表示让编译器检查，当前module是否实现了gen_server指定的所有回调接口</p>\n<p>2.gen_server:start_link(ServerName, Module, Args, Options) -&gt; Result<br>这个方法用来启动一个server，其中：<br>参数ServerName指定了服务名<br>参数Module指定了该server的callback模块<br>参数Args将作为服务初始化的启动参数（服务初始化时会调用：Module:init([Args])）<br>参数Options指定了一些特性参数，通常可以直接使用[] </p>\n<p>如果服务启动成功，返回{ok, Pid} </p>\n<p>3.Module:init([Args])<br>这个方法会在服务初始化时被回调，参数Args就是gen_server:start_link中倒数第二个参数，若初始化成功，该方法放回{ok, State},其中State将作为启动服务的State </p>\n<p>4.gen_server:call(ServerRef, Request)<br>这个方法供callback模块向ServerRef代表的服务发送Request请求（callback模块通常会在之上再封装一层接口供客户端调用，譬如这里的add，find方法），注意该方法是一个同步调用，它会一直等待服务器返回一个响应消息（除非等待超时，默认5s） </p>\n<p>5.Module:handle_call(Request, From, State) -&gt; Result<br>这是一个回调方法，用来处理gen_server:call(ServerRef, Request)发出的请求，其中：<br>Request，表示客户端请求<br>From，表示请求来自哪个客户端<br>State，表示当前服务器状态 </p>\n<p>Result为handle_call 请求处理结果，它有以下几种类型<br>{reply,Reply,NewState}<br>{reply,Reply,NewState,Timeout}<br>{reply,Reply,NewState,hibernate}<br>{noreply,NewState}<br>{noreply,NewState,Timeout}<br>{noreply,NewState,hibernate}<br>{stop,Reason,Reply,NewState} | {stop,Reason,NewState} </p>\n<p>这几种返回值有什么区别呢？<br>如果返回的是以reply开头，那么Reply将会作为响应返回给客户端<br>如果返回的是以noreply开头，那么服务器将不会返回任何消息给客户端（这会导致客户端阻塞，因为客户端调用的gen_server:call方法是一个同步调用，当它发出请求后，会一直等待服务器发送响应消息，除非等待超时） </p>\n<p>6.gen_server:cast(ServerRef, Request)<br>这个方法同gen_server:call(ServerRef, Request)，但它最大的区别就是该调用是异步的，它不需要等待服务器返回任何处理结果 </p>\n<p>7.Module:handle_cast(Request, State) -&gt; Result<br>这个方法用来处理gen_server:cast(ServerRef, Request)发出的请求，由于不会返回结果给客户端，所以参数列表中也没有From </p>\n<p>8.检查进程是否加载<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erlang:whereis(?MODULE).</span><br></pre></td></tr></table></figure></p>\n<p>9.查看进程的信息<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erlang:process_info(pid(0,PID,0)).</span><br></pre></td></tr></table></figure></p>\n","text":"1.-behaviour(gen_server)<br>它表示让编译器检查，当前module是否实现了gen_server指定的所有回调接口2.gen_server:start_link(ServerName, Module, Args, Options) -&gt; Resul","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Erlang","slug":"Erlang","count":2,"path":"api/tags/Erlang.json"}]},{"title":"Erlang List模块函数使用大全","slug":"Erlang List模块函数使用大全","date":"2019-05-07T11:49:16.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"api/articles/Erlang List模块函数使用大全.json","excerpt":"<p>Erlang List模块函数使用大全</p>\n<p>一，带函数Pred<br>1, all(Pred, List) -&gt; boolean()<br>如果List中的每个元素作为Pred函数的参数执行，结果都返回true，那么all函数返回true，<br>否则返回false</p>\n<p>例子：</p>\n<p>lists:all(fun(E) -&gt; true end,[1,2,3,4]).</p>\n<p>结果</p>\n<p>true</p>\n<p>2, any(Pred, List) -&gt; boolean()<br>如果List中至少有一个元素作为Pred函数的参数执行，结果返回true，那么any函数返回true，<br>否则返回false</p>\n<p>例子</p>\n<p>lists:any(fun(E) -&gt; is_integer(E) end,[q,2,a,4]).</p>\n<p>结果</p>\n<p>true</p>\n<p>3，dropwhile(Pred, List1) -&gt; List2<br>将List1列表中的元素作为参数执行Pred函数，如果返回true，将其丢弃，最后返回剩余元素<br>组成的列表</p>\n<p>例子</p>\n<p>lists:dropwhile(fun(E) -&gt; is_atom(E) end,[a,1,2,a,b]).</p>\n<p>结果</p>\n<p>[1,2,a,b]</p>\n<p>4，filter(Pred, List1) -&gt; List2<br>返回一个列表，这个列表是由List1中执行Pred函数返回true的元素组成。</p>\n<p>lists:filter(fun(E) -&gt; is_integer(E) end,[q,2,a,4]).</p>\n<p>结果：</p>\n<p>[2,4]</p>","keywords":null,"cover":null,"content":null,"text":"Erlang List模块函数使用大全一，带函数Pred<br>1, all(Pred, List) -&gt; boolean()<br>如果List中的每个元素作为Pred函数的参数执行，结果都返回true，那么all函数返回true，<br>否则返回false例子：list","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Erlang","slug":"Erlang","count":2,"path":"api/tags/Erlang.json"}]}]}